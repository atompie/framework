<?php
namespace AtomPie\Gui\Component {

    use AtomPie\Boundary\Core\EventBus\IHandleEvents;
    use AtomPie\Boundary\Core\ISerializeModel;
    use AtomPie\Boundary\Gui\Component\IAmNamespaceValue;
    use AtomPie\EventBus\EventHandler;
    use AtomPie\Annotation\AnnotationParser;
    use AtomPie\DependencyInjection\Boundary\IConstructInjection;
    use AtomPie\DependencyInjection\DependencyContainer;
    use AtomPie\DependencyInjection\DependencyInjector;
    use Generi\Boundary\ICanBeIdentified;
    use AtomPie\Boundary\Gui\Component\IAmComponent;
    use AtomPie\Boundary\Gui\Component\IControlAccess;
    use AtomPie\Boundary\Gui\Component\IHaveContext;
    // Classes
    use AtomPie\Boundary\Core\Dispatch\IHaveEventSpec;
    use AtomPie\Gui\Component\RecursiveInvoker\EventTreeInvoker;
    use AtomPie\System\IO\File;
    // Dependencies
    use AtomPie\I18n\Label;
    use AtomPie\Gui\Component\Annotation;
    use AtomPie\Gui\Component;

    /**
     * Class Part for Page and Component
     * @package FrontEnd
     */
    class Part extends PlaceHolder implements
        ICanBeIdentified, IAmComponent, IHandleEvents, ISerializeModel
    {

        use EventHandler;

        const TOP_COMPONENT_NAME = 'Top';

        /**
         * @var IConstructInjection
         */
        private static $oDependencyContainer;

        /**
         * @var string
         */
        private $sName;

        /**
         * @var IAmNamespaceValue
         */
        private $oNamespace;

        /**
         * Used to differentiate factored components from not factored.
         * Each component must be factored once.
         *
         * @var bool
         */
        private $bIsFactored = false;

        /**
         * Used to differentiate processed components from not processed.
         * Each component must be processed once.
         *
         * @var bool
         */
        private $bIsProcessed = false;

        /**
         * Used to differentiate components that triggered events
         * from those that are new and need events to be triggered.
         * Each component invoke event once.
         *
         * @var bool
         */
        private $bIsEventRaised = false;

        /**
         * Returns information if the any of the placeholders in tree was updated,
         * and the whole tree need to be reevaluated.
         *
         * @var bool
         */
        private static $bIsValid = true;

        /**
         * Name is the name of the component. Name must be unique within
         * tree of components.
         *
         * $oContext is an context component is running in. Basically it is the
         * parent component, therefore just pass $this and everything will be fine.
         *
         * @param string $sName
         * @param \AtomPie\Boundary\Gui\Component\IHaveContext $oContext
         */
        public function __construct($sName, IHaveContext $oContext)
        {

            if ($this instanceof IControlAccess) {

                // Fall back to global authorization

                if (true !== $this->authorize()) {
                    $this->invokeNotAuthorized();
                }

            }

            if ($sName instanceof AutoGeneratedName) {
                $sName = $sName->__toString();
            }

            $this->setName($sName);

            // Set namespace

            $this->setNamespace(new NamespaceValue($oContext->getNamespace()->__toString(), $sName));

            // Run create
            if (method_exists($this, '__create')) {
                $oInjector = new DependencyInjector($this->getComponentDependencyContainer());
                $oInjector->invokeMethod($this, '__create');
            }

        }

        /////////////////////////////
        // ICanBeRendered

        public function getViewPlaceHolders()
        {
            return $this->getPlaceHolders();
        }

        /**
         * @param $sFolder
         * @return File
         * @throws Exception
         */
        public function getTemplateFile($sFolder)
        {

            // Set default set of Annotations
            $aDefaultComponentClassAnnotations = array(
                'Template' => \AtomPie\AnnotationTag\Template::class
            );

            $oParser = new AnnotationParser();
            $oAnnotations = $oParser->getAnnotationsFromObjectOrMethod(
                $aDefaultComponentClassAnnotations,
                $this
            );
            /** @var \AtomPie\AnnotationTag\Template $oTemplateTag */
            $oTemplateTag = $oAnnotations->getFirstAnnotationByType(\AtomPie\AnnotationTag\Template::class);

            // Template annotation is required while rendering.

            if ($oTemplateTag === null) {
                throw new Exception(
                    sprintf(new Label('Template path not defined in component [%s]. Please annotate class with @Template(File="TemplateName.mustache")'),
                        $this->getType()->getFullName())
                );
            }

            $sPathCandidate = $sFolder . DIRECTORY_SEPARATOR . $oTemplateTag->File;

            $sPath = realpath($sPathCandidate);
            if (false === $sPath) {
                throw new Exception(
                    sprintf(
                        new Label('Incorrect template path. Template file [%s] does not exist within folder [%s].'),
                        $oTemplateTag->File,
                        $sPathCandidate
                    )
                );
            }

            return new File($sPath);

        }

        /////////////////////////////
        // IHaveEvents

        public function emitRequestEvent(
            IConstructInjection $oComponentDependencyContainer,
            IHaveEventSpec $oDispatchManifest
        ) {
            $oEventTreeInvoker = new EventTreeInvoker();
            $oEventTreeInvoker->invokeEvent(
                $oComponentDependencyContainer,
                $this,
                $oDispatchManifest
            );
        }

        //////////////////////////////////////
        // Marking factoring

        /**
         * @internal
         */
        public function markFactored()
        {
            $this->bIsFactored = true;
        }

        /**
         * @internal
         * @return bool
         */
        public function isFactored()
        {
            return $this->bIsFactored;
        }

        //////////////////////////////////////
        // Marking processing

        /**
         * @internal
         */
        public function markProcessed()
        {
            $this->bIsProcessed = true;
        }

        /**
         * @internal
         * @return bool
         */
        public function isProcessed()
        {
            return $this->bIsProcessed;
        }

        //////////////////////////////////////
        // Marking events

        /**
         * Internal component method used during dispatch.
         * Marks component events as triggered.
         *
         * @internal
         */
        public function markEventRaised()
        {
            $this->bIsEventRaised = true;
        }

        /**
         * Returns TRUE if request event of the component was raised.
         *
         * @internal
         * @return bool
         */
        public function isEventRaised()
        {
            return $this->bIsEventRaised;
        }

        ////////////////////////////
        // \IHaveNamespace

        /**
         * Returns full namespace of the component.
         *
         * @return NamespaceValue
         */
        public function getNamespace()
        {
            return $this->oNamespace;
        }

        /**
         * @param IAmNamespaceValue $oNamespace
         */
        private function setNamespace(IAmNamespaceValue $oNamespace)
        {
            $this->oNamespace = $oNamespace;
        }

        //////////////////////////////////////

        /**
         * Fill placeholder within component with value. Value can be any
         * object that can render to string e.g. another component.
         *
         * @param $sName
         * @param $mValue
         */
        public function __set($sName, $mValue)
        {

            parent::__set($sName, $mValue);

            if ($mValue instanceof Part) {
                $this->markDirtyPlaceHolder();
            }

        }

        //////////////////////////////
        // Marking dirty

        /**
         * Marks component dirty.
         */
        private function markDirtyPlaceHolder()
        {
            self::$bIsValid = false;
        }

        /**
         * @return void
         */
        public function markTreeClean()
        {
            self::$bIsValid = true;
        }

        /**
         * @return boolean
         */
        public function isTreeDirty()
        {
            return !self::$bIsValid;
        }

        ///////////////////////////
        //  \IHaveName

        /**
         * Returns true if component has a name, otherwise false.
         *
         * @return boolean
         */
        public function hasName()
        {
            return !empty($this->sName);
        }


        /**
         * Returns component name.
         *
         * @return string
         */
        public function getName()
        {
            return $this->sName;
        }

        /**
         * @param string $sName
         * @throws Exception
         */
        private function setName($sName)
        {
            if (!is_string($sName)) {
                throw new Exception('Component name can only be string');
            }
            $this->sName = $sName;
        }

        //////////////////////////////////

        /**
         * @param $aData
         * @return $this
         */
        public function filledWith($aData)
        {
            $this->setPlaceHolders($aData);
            return $this;
        }

        //////////////////////////////////////////
        // Dependency injection

        /**
         * @return IConstructInjection
         */
        public function getComponentDependencyContainer()
        {
            if (isset(self::$oDependencyContainer)) {
                return self::$oDependencyContainer;
            } else {
                return new DependencyContainer();
            }
        }

        public static function injectDependency(IConstructInjection $oDependencyContainer)
        {
            self::$oDependencyContainer = $oDependencyContainer;
        }

        ////////////////////////////
        // ISerializeModel

        /**
         * Returns array with model data to be serialized
         * during json or XML serialization.
         *
         * @return array
         */
        public function __toModel()
        {
            return $this->getPlaceHolders();
        }
    }

}
